import numpy as np
import math
import matplotlib.pyplot as plt

# ----------- system dynamic parameters --------------------

r = 0.5 # Radius of Wheel 
l = 2.5 # Length of link
m = 500 # Mass of Link
M = 80 # Mass of wheel
a = 1.0 # center of mass of link from wheel center
g = 9.81 # Gravity


kp1 = 12100.0
kp2 = 400.0

# differential coefficients
kd1 = 2500.0
kd2 = 10 * 200.0

A = m * (a**2 + (l**2) / 12)
B = m * a * r
C = (m + 3 / 2 * M) * r**2

D = A * C
E = B ** 2
F = m * g * a


class RobotDynamics:
    def __init__(self, starting_position = 0, starting_angle = 30.0):
        self.t = 0.0
        self.x1 = np.radians(starting_angle)  # theta - pendulum
        self.x2 = 0               # theta_dot - pendulum
        self.x3 = 0               # phi  - wheel
        self.x4 = 0               # phi_dot - wheel
    
        self.position = starting_position

    # -----------------------------------------------------------
    # Torque generated by motor installed in wheel
    def controlTrq(self, theta, phi, theta_dot, phi_dot):
        control = kp1 * theta + kd1 * theta_dot + kp2 * theta_dot + kd2 * phi_dot
        return control

    # DYNAMIC EQUATIONS
    # theta_dot 
    # pendulum angular velocity
    def function1(self, fi):
        return fi

    # theta_dot_dot 
    # pendulum angular acceleration
    def function2(self, theta, phi, theta_dot, phi_dot):
        theta_dot_dot = (C * (F * np.sin(theta) - self.controlTrq(theta, phi, theta_dot, phi_dot)) - 
                        B * np.cos(theta) * (self.controlTrq(theta, phi, theta_dot, phi_dot) + B * (phi**2) * np.sin(theta))) / (D - E * (np.cos(theta))**2)
        return theta_dot_dot

    # phi_dot
    # wheel angular velocity
    def function3(self, phi_dot):
        return phi_dot

    # phi_dot_dot
    # wheel angular acceleration
    def function4(self, theta, phi, theta_dot, phi_dot):
        phi_dot_dot = (A * (F * np.sin(theta) - self.controlTrq(theta, phi, theta_dot, phi_dot)) - 
                    B * np.cos(theta) * (self.controlTrq(theta, phi, theta_dot, phi_dot) + B * (phi**2) * np.sin(theta))) / (D - E * (np.cos(theta))**2)
        return phi_dot_dot


    def next_step(self, dt = 0.001):
        # init values
        self.t += dt
        k11 = self.function1(self.x2)
        k12 = self.function2(self.x1, self.x2, self.x3, self.x4)
        k13 = self.function3(self.x4)
        k14 = self.function4(self.x1, self.x2, self.x3, self.x4)

        k21 = self.function1(self.x2 + dt / 2 * k12)
        k22 = self.function2(self.x1 + dt / 2 * k11, self.x2 + dt / 2 * k12, self.x3 + dt / 2 * k13, self.x4 + dt / 2 * k14)
        k23 = self.function3(self.x4 + dt / 2 * k14)
        k24 = self.function4(self.x1 + dt / 2 * k11, self.x2 + dt / 2 * k12, self.x3 + dt / 2 * k13, self.x4 + dt / 2 * k14)

        k31 = self.function1(self.x2 + dt / 2 * k22)
        k32 = self.function2(self.x1 + dt / 2 * k21, self.x2 + dt / 2 * k22, self.x3 + dt / 2 * k23, self.x4 + dt / 2 * k24)
        k33 = self.function3(self.x4 + dt / 2 * k24)
        k34 = self.function4(self.x1 + dt / 2 * k21, self.x2 + dt / 2 * k22, self.x3 + dt / 2 * k23, self.x4 + dt / 2 * k24)

        k41 = self.function1(self.x2 + dt * k32)
        k42 = self.function2(self.x1 + dt * k31, self.x2 + dt * k32, self.x3 + dt * k33, self.x4 + dt * k34)
        k43 = self.function3(self.x4 + dt * k34)
        k44 = self.function4(self.x1 + dt * k31, self.x2 + dt * k32, self.x3 + dt * k33, self.x4 + dt * k34)


        self.x1 += dt / 6.0 * (k11 + 2 * k21 + 2 * k31 + k41)
        self.x2 += dt / 6.0 * (k12 + 2 * k22 + 2 * k32 + k42)
        x3_change = dt / 6.0 * (k13 + 2 * k23 + 2 * k33 + k43)
        self.x3 +=  x3_change

        self.x4 += dt / 6.0 * (k14 + 2 * k24 + 2 * k34 + k44)

        self.position = 2*math.pi*r * x3_change

        return self.position, self.x3
